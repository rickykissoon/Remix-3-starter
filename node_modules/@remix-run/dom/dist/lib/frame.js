import { createElement, createFrameHandle } from "./component.js";
import { invariant } from "./invariant.js";
import { diffNodes } from "./diff-dom.js";
import { createRangeRoot, createScheduler } from "./vdom.js";
const TOP_FRAME = Symbol('TOP_FRAME');
const defaultInit = {
    loadModule: async () => {
        throw new Error('loadModule not implemented');
    },
    pendingHydrationRoots: new Map(),
    src: '/',
    scheduler: createScheduler(),
    resolveFrame: async () => {
        throw new Error('resolveFrame not implemented');
    },
};
export function createFrame(root, init) {
    let config = { ...defaultInit, ...init };
    let container = createContainer(root);
    let scheduler = config.scheduler;
    let frame = createFrameHandle({
        src: config.src,
        reload: async () => {
            let content = await config.resolveFrame(config.src);
            await render(content);
        },
        replace: async (content) => {
            await render(content);
        },
    });
    let context = {
        frame,
        loadModule: config.loadModule,
        pendingRoots: config.pendingHydrationRoots,
        scheduler: config.scheduler,
        addFrame(start) {
            let end = findEndComment(start);
            let script = end.nextElementSibling;
            invariant(script instanceof HTMLScriptElement, 'Invalid frame script');
            let marker = parseFrameScript(script);
            createFrame([start, end], { ...config, src: marker.src, marker });
            return script;
        },
    };
    async function render(content) {
        let fragment = typeof content === 'string' ? createFragmentFromString(content) : content;
        let nextContainer = createContainer(fragment);
        await populatePendingRoots(nextContainer, context);
        diffNodes(container.childNodes, Array.from(nextContainer.childNodes), context);
        hydratedAndCreateSubFrames(container.childNodes, context);
    }
    async function hydrate() {
        await populatePendingRoots(container, context);
        hydratedAndCreateSubFrames(Array.from(container.childNodes), context);
        if (config.marker?.status === 'pending') {
            let earlyContent = getEarlyFrameContent(config.marker.id);
            if (earlyContent) {
                await render(earlyContent);
            }
            else {
                setupTemplateObserver(config.marker.id, render);
            }
        }
    }
    let hydratePromise = hydrate();
    return {
        render,
        ready: () => hydratePromise,
        flush: () => scheduler.dequeue(),
    };
}
function getEarlyFrameContent(id) {
    let template = document.querySelector(`template#${id}`);
    if (template instanceof HTMLTemplateElement) {
        let fragment = template.content;
        template.remove();
        return fragment;
    }
    return null;
}
function setupTemplateObserver(id, cb) {
    let observer = new MutationObserver(async (mutations) => {
        for (let mutation of mutations) {
            for (let node of mutation.addedNodes) {
                if (node instanceof HTMLTemplateElement && node.id === id) {
                    observer.disconnect();
                    node.remove();
                    cb(node.content);
                }
            }
        }
    });
    observer.observe(document.body, { childList: true });
}
function parseFrameScript(script) {
    let data = JSON.parse(script.textContent || '{}');
    invariant(isFrameMarker(data));
    return data;
}
function isFrameMarker(object) {
    return (typeof object === 'object' &&
        object !== null &&
        'src' in object &&
        'id' in object &&
        'status' in object);
}
function findEndComment(comment) {
    let node = comment.nextSibling;
    while (node && node.nodeType !== 8) {
        node = node.nextSibling;
        if (node instanceof Comment && node.data.trim().startsWith('frame:end')) {
            return node;
        }
    }
    throw new Error('End comment not found');
}
function findCommentAbove(anchor, data) {
    let node = anchor.previousSibling;
    while (node && node.nodeType !== 8) {
        node = node.previousSibling;
        if (node instanceof Comment && node.data.trim() === data) {
            return node;
        }
    }
    invariant(false, 'Start comment not found');
}
function hydrate(vElement, start, end, context) {
    context.pendingRoots.delete(start);
    let root = createRangeRoot([start, end], {
        scheduler: context.scheduler,
        frame: context.frame,
        // TODO: vParent: context.vParent,
    });
    Object.defineProperty(start, '$rmx', { value: root, enumerable: false });
    root.render(vElement);
}
export function isVirtualStartMarker(node) {
    return '$rmx' in node;
}
function hydratedAndCreateSubFrames(nodes, context) {
    for (let i = 0; i < nodes.length; i++) {
        let node = nodes[i];
        if (node instanceof Comment && context.pendingRoots.has(node)) {
            let info = context.pendingRoots.get(node);
            invariant(info, 'Expected hydration element');
            let [end, element] = info;
            hydrate(element, node, end, context);
            // advance cursor to node after end marker
            i = nodes.indexOf(end);
        }
        if (isFrameStart(node)) {
            let frameScript = context.addFrame(node);
            i = nodes.indexOf(frameScript); // advance past frame script
            frameScript.remove();
        }
        else if (node.childNodes.length > 0) {
            hydratedAndCreateSubFrames(Array.from(node.childNodes), context);
        }
    }
}
function createFragmentFromString(content) {
    let template = document.createElement('template');
    template.innerHTML = content.trim();
    return template.content;
}
function isFrameStart(node) {
    return node instanceof Comment && node.data.trim().startsWith('frame:start:');
}
const hydrationScriptSelector = 'script[type="application/json"][rmx-hydrated]';
// pending roots map is shared by child frames so we can populate from the
// parent and load all found modules in parallel and keep diffing synchronous
async function populatePendingRoots(container, context) {
    let scripts = queryHydrationScripts(container);
    await Promise.all(scripts.map(async (script) => {
        let data = JSON.parse(script.textContent || '{}');
        invariant(isHydrationScript(data), 'Invalid hydration script');
        let mod = await context.loadModule(data.moduleUrl, data.exportName);
        let vElement = createElement(mod, data.props);
        let [start, end] = getVirtualRootMarkersFromScript(script);
        context.pendingRoots.set(start, [end, vElement]);
        script.remove(); // remove before diffing
    }));
}
function getVirtualRootMarkersFromScript(script) {
    let end = script.previousSibling;
    invariant(end instanceof Comment, 'Expected comment');
    let start = findCommentAbove(end, 'rmx:h');
    return [start, end];
}
function queryHydrationScripts(container) {
    return Array.from(container.root.querySelectorAll(hydrationScriptSelector));
}
function isHydrationScript(object) {
    return (typeof object === 'object' &&
        object !== null &&
        'moduleUrl' in object &&
        'exportName' in object &&
        'props' in object);
}
function createContainer(container) {
    return Array.isArray(container)
        ? createCommentContainer(container)
        : createElementContainer(container);
}
function createElementContainer(container) {
    return {
        root: container,
        appendChild: (node) => container.appendChild(node),
        get childNodes() {
            return Array.from(container.childNodes);
        },
        querySelectorAll: (selector) => Array.from(container.querySelectorAll(selector)),
        querySelector: (selector) => container.querySelector(selector),
        insertBefore: (node, before) => container.insertBefore(node, before),
    };
}
function createCommentContainer(container) {
    let root = container[1].parentNode;
    invariant(root, 'Invalid comment container');
    let appendChild = (node) => {
        root.insertBefore(node, container[1]);
    };
    let getChildNodesBetween = () => {
        let nodes = [];
        let node = container[0].nextSibling;
        while (node && node !== container[1]) {
            nodes.push(node);
            node = node.nextSibling;
        }
        return nodes;
    };
    let querySelectorAll = (selector) => {
        let range = document.createRange();
        range.setStartAfter(container[0]);
        range.setEndBefore(container[1]);
        let all = root.querySelectorAll(selector);
        let results = [];
        for (let i = 0; i < all.length; i++) {
            let el = all[i];
            if (range.intersectsNode(el))
                results.push(el);
        }
        return results;
    };
    let querySelector = (selector) => {
        let range = document.createRange();
        range.setStartAfter(container[0]);
        range.setEndBefore(container[1]);
        let all = root.querySelectorAll(selector);
        for (let i = 0; i < all.length; i++) {
            let el = all[i];
            if (range.intersectsNode(el))
                return el;
        }
        return null;
    };
    let insertBefore = (node, before) => {
        root.insertBefore(node, before);
    };
    return {
        get childNodes() {
            return getChildNodesBetween();
        },
        appendChild,
        querySelectorAll,
        querySelector,
        insertBefore,
        root,
    };
}
//# sourceMappingURL=frame.js.map