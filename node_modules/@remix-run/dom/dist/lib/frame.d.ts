import { type Remix } from './component.ts';
import type { Scheduler } from './vdom.ts';
declare module './component.ts' {
    namespace Remix {
        interface Frame {
            render: (content: Remix.FrameContent) => Promise<void>;
            ready: () => Promise<void>;
            flush: () => void;
        }
    }
}
type FrameRoot = [Comment, Comment] | Element | Document | DocumentFragment;
type FrameMarkerData = {
    src: string;
    status: 'pending' | 'resolved';
    name?: string;
    id: string;
};
export type VirtualRootMarker = Comment & {
    $rmx: Remix.VirtualRoot;
};
type PendingHydrationRoots = Map<Comment, [Comment, Remix.RemixElement]>;
type LoadModule = (src: string, name: string) => Promise<Function> | Function;
type ResolveFrame = (src: string) => Promise<Remix.FrameContent> | Remix.FrameContent;
export type FrameContext = {
    loadModule: LoadModule;
    pendingRoots: PendingHydrationRoots;
    addFrame: (node: Comment) => HTMLScriptElement;
    frame: Remix.FrameHandle;
    scheduler: Scheduler;
};
type FrameInit = {
    src: string;
    loadModule: LoadModule;
    pendingHydrationRoots: PendingHydrationRoots;
    marker?: FrameMarkerData;
    scheduler: Scheduler;
    resolveFrame: ResolveFrame;
};
export declare function createFrame(root: FrameRoot, init?: Partial<FrameInit>): Remix.Frame;
export declare function isVirtualStartMarker(node: Node): node is VirtualRootMarker;
export {};
//# sourceMappingURL=frame.d.ts.map