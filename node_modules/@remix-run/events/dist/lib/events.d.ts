export declare function debug(): void;
/**
 * Adds events to a target and returns a function to clean them up.
 *
 * @example
 * ```ts
 * import { events, dom } from "@remix-run/events";
 *
 * let cleanup = events(target, [
 *   dom.click(event => {
 *     console.log(event.target);
 *   })
 * ])
 * ```
 */
export declare function events<Target extends EventTarget>(target: Target, descriptors: EventDescriptor<Target>[]): Cleanup;
/**
 * Creates a new event container for the given target. Events can be changed
 * dynamically and cleaned up later.
 *
 * @example
 * ```ts
 * import { events, dom } from "@remix-run/events";
 *
 * let container= events(target)
 *
 * container.on([
 *   dom.click(event => {
 *     console.log("first handler");
 *   })
 * ]);
 *
 * container.cleanup();
 * ```
 */
export declare function events<Target extends EventTarget>(target: Target): EventContainer;
/**
 * Attach a raw string event to a target. Particularly useful for custom
 * elements and web components.
 *
 * @example
 * ```ts
 * import { events, bind } from "@remix-run/events";
 *
 * events(target, [
 *   bind("custom", event => {
 *     console.log(event.target);
 *   })
 * ])
 * ```
 */
export declare function bind<E extends Event = Event, ECurrentTarget = any, ETarget = any>(type: string, handler: EventHandler<E, ECurrentTarget, ETarget>, options?: AddEventListenerOptions): EventDescriptor<ECurrentTarget>;
export type EventHandler<E = Event, ECurrentTarget = any, ETarget = any> = (event: EventWithTargets<E, ECurrentTarget, ETarget>, signal: AbortSignal) => any | Promise<any>;
export interface EventDescriptor<ECurrentTarget = any> {
    type: string;
    handler: EventHandler<any, ECurrentTarget>;
    isCustom?: boolean;
    options?: AddEventListenerOptions;
}
export type EventWithTargets<E = Event, ECurrentTarget = any, ETarget = any> = Omit<E, 'target' | 'currentTarget'> & {
    target: ETarget;
    currentTarget: ECurrentTarget;
};
export interface EventContainer {
    on: (events: EventDescriptor | EventDescriptor[] | undefined) => void;
    cleanup: () => void;
}
export type Cleanup = () => void;
