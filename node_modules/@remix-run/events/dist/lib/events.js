let _debug = false;
export function debug() {
    _debug = true;
}
function log(...args) {
    if (_debug) {
        console.log('DEBUG', ...args);
    }
}
export function events(target, initialDescriptors) {
    let descriptors = [];
    let cleanups = [];
    let on = (nextDescriptors) => {
        if (!nextDescriptors) {
            nextDescriptors = [];
        }
        if (!Array.isArray(nextDescriptors)) {
            nextDescriptors = [nextDescriptors];
        }
        if (descriptorsChanged(descriptors, nextDescriptors)) {
            cleanupAll(cleanups);
            cleanups = [];
            if (nextDescriptors.length > 0) {
                attachAllEvents(target, nextDescriptors, cleanups);
            }
            descriptors = nextDescriptors;
        }
        else {
            updateHandlersInPlace(descriptors, nextDescriptors);
        }
    };
    let cleanup = () => {
        cleanupAll(cleanups);
        descriptors = [];
        cleanups = [];
    };
    if (initialDescriptors) {
        on(initialDescriptors);
        return cleanup;
    }
    return { on, cleanup };
}
/**
 * Attach a raw string event to a target. Particularly useful for custom
 * elements and web components.
 *
 * @example
 * ```ts
 * import { events, bind } from "@remix-run/events";
 *
 * events(target, [
 *   bind("custom", event => {
 *     console.log(event.target);
 *   })
 * ])
 * ```
 */
export function bind(type, handler, options) {
    return { type, handler, options };
}
function shallowEqual(a, b) {
    if (a === b)
        return true;
    if (!a || !b)
        return false;
    if (typeof a !== 'object' || typeof b !== 'object')
        return false;
    let keysA = Object.keys(a);
    let keysB = Object.keys(b);
    if (keysA.length !== keysB.length)
        return false;
    for (let key of keysA) {
        if (a[key] !== b[key])
            return false;
    }
    return true;
}
function createDispatcher(target, type) {
    return (options, originalEvent) => {
        let customEvent = new CustomEvent(type, {
            bubbles: true,
            cancelable: true,
            ...options,
        });
        // Patch stopPropagation to also stop the original event
        if (originalEvent) {
            let originalStopPropagation = customEvent.stopPropagation.bind(customEvent);
            customEvent.stopPropagation = () => {
                originalStopPropagation();
                originalEvent.stopPropagation();
            };
        }
        target.dispatchEvent(customEvent);
    };
}
function prepareInteractions(target, descriptors, cleanups) {
    // Only prepare once per unique event type (which now includes options in the name)
    let seenEventTypes = new Set();
    for (let descriptor of descriptors) {
        if (seenEventTypes.has(descriptor.type)) {
            continue; // Skip if we've already prepared this event type
        }
        seenEventTypes.add(descriptor.type);
        let dispatch = createDispatcher(target, descriptor.type);
        let factoryResult = descriptor.factory({ dispatch, target }, descriptor.factoryOptions);
        if (factoryResult) {
            let factoryCleanups = Array.isArray(factoryResult) ? factoryResult : [factoryResult];
            cleanups.push(...factoryCleanups);
        }
    }
}
function attach(target, eventType, descriptors, cleanups) {
    log('attach', { target, eventType, descriptors });
    let preventedEvents = new Set();
    for (let descriptor of descriptors) {
        let controller = new AbortController();
        let wrappedHandler = (event) => {
            controller.abort(new DOMException('Handler reentered', 'EventReentry'));
            controller = new AbortController();
            log('wrappedHandler', { target, eventType, event });
            if (preventedEvents.has(event)) {
                log('prevented', { target, eventType, event });
                return;
            }
            let call = descriptor.handler(event, controller.signal);
            if (call instanceof Promise) {
                call.catch((e) => {
                    if (e instanceof DOMException && e.name === 'EventReentry') {
                        // swallow
                    }
                    else {
                        throw e;
                    }
                });
            }
            if (event.defaultPrevented) {
                preventedEvents.add(event);
                setTimeout(() => preventedEvents.delete(event), 0);
            }
        };
        target.addEventListener(eventType, wrappedHandler, descriptor.options);
        cleanups.push(() => {
            controller.abort();
            target.removeEventListener(eventType, wrappedHandler, descriptor.options);
        });
    }
}
function attachStandardEvents(target, descriptors, cleanups) {
    let eventsByType = new Map();
    for (let descriptor of descriptors) {
        if (!eventsByType.has(descriptor.type)) {
            eventsByType.set(descriptor.type, []);
        }
        eventsByType.get(descriptor.type).push(descriptor);
    }
    for (let [type, descriptors] of eventsByType) {
        attach(target, type, descriptors, cleanups);
    }
}
function attachInteractions(target, descriptors, cleanups) {
    let byType = new Map();
    for (let descriptor of descriptors) {
        if (!byType.has(descriptor.type)) {
            byType.set(descriptor.type, []);
        }
        byType.get(descriptor.type).push(descriptor);
    }
    for (let [type, descriptors] of byType) {
        attach(target, type, descriptors, cleanups);
    }
}
function attachAllEvents(target, descriptors, cleanups) {
    let { custom, standard } = splitDescriptors(descriptors);
    prepareInteractions(target, custom, cleanups);
    attachInteractions(target, custom, cleanups);
    attachStandardEvents(target, standard, cleanups);
}
function splitDescriptors(descriptors) {
    let custom = [];
    let standard = [];
    for (let descriptor of descriptors) {
        if (isInteractionDescriptor(descriptor)) {
            custom.push(descriptor);
        }
        else {
            standard.push(descriptor);
        }
    }
    return { custom, standard };
}
function isInteractionDescriptor(descriptor) {
    return descriptor.isCustom === true;
}
function descriptorsChanged(descriptors, nextDescriptors) {
    if (descriptors.length !== nextDescriptors.length) {
        return true;
    }
    for (let i = 0; i < descriptors.length; i++) {
        let current = descriptors[i];
        let next = nextDescriptors[i];
        if (current.type !== next.type ||
            current.isCustom !== next.isCustom ||
            !shallowEqual(current.options, next.options) ||
            !shallowEqual(current.factoryOptions, next.factoryOptions)) {
            return true;
        }
    }
    return false;
}
function updateHandlersInPlace(descriptors, nextDescriptors) {
    for (let i = 0; i < nextDescriptors.length; i++) {
        descriptors[i].handler = nextDescriptors[i].handler;
    }
}
function cleanupAll(cleanups) {
    for (let cleanup of cleanups)
        cleanup();
}
//# sourceMappingURL=events.js.map