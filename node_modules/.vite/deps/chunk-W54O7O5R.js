// node_modules/@remix-run/events/dist/lib/interactions.js
function createEventNameWithOptions(baseName, options) {
  if (!options || Object.keys(options).length === 0) {
    return baseName;
  }
  let params = new URLSearchParams();
  let sortedKeys = Object.keys(options).sort();
  for (let key of sortedKeys) {
    params.append(key, String(options[key]));
  }
  return `${baseName}?${params.toString()}`;
}
function createInteraction(eventName, factory) {
  return (handler, options) => {
    let finalEventName = createEventNameWithOptions(eventName, options);
    return {
      type: finalEventName,
      handler,
      isCustom: true,
      factoryOptions: options,
      factory
    };
  };
}

// node_modules/@remix-run/events/dist/lib/events.js
var _debug = false;
function log(...args) {
  if (_debug) {
    console.log("DEBUG", ...args);
  }
}
function events(target, initialDescriptors) {
  let descriptors = [];
  let cleanups = [];
  let on = (nextDescriptors) => {
    if (!nextDescriptors) {
      nextDescriptors = [];
    }
    if (!Array.isArray(nextDescriptors)) {
      nextDescriptors = [nextDescriptors];
    }
    if (descriptorsChanged(descriptors, nextDescriptors)) {
      cleanupAll(cleanups);
      cleanups = [];
      if (nextDescriptors.length > 0) {
        attachAllEvents(target, nextDescriptors, cleanups);
      }
      descriptors = nextDescriptors;
    } else {
      updateHandlersInPlace(descriptors, nextDescriptors);
    }
  };
  let cleanup = () => {
    cleanupAll(cleanups);
    descriptors = [];
    cleanups = [];
  };
  if (initialDescriptors) {
    on(initialDescriptors);
    return cleanup;
  }
  return { on, cleanup };
}
function bind(type, handler, options) {
  return { type, handler, options };
}
function shallowEqual(a, b) {
  if (a === b)
    return true;
  if (!a || !b)
    return false;
  if (typeof a !== "object" || typeof b !== "object")
    return false;
  let keysA = Object.keys(a);
  let keysB = Object.keys(b);
  if (keysA.length !== keysB.length)
    return false;
  for (let key of keysA) {
    if (a[key] !== b[key])
      return false;
  }
  return true;
}
function createDispatcher(target, type) {
  return (options, originalEvent) => {
    let customEvent = new CustomEvent(type, {
      bubbles: true,
      cancelable: true,
      ...options
    });
    if (originalEvent) {
      let originalStopPropagation = customEvent.stopPropagation.bind(customEvent);
      customEvent.stopPropagation = () => {
        originalStopPropagation();
        originalEvent.stopPropagation();
      };
    }
    target.dispatchEvent(customEvent);
  };
}
function prepareInteractions(target, descriptors, cleanups) {
  let seenEventTypes = /* @__PURE__ */ new Set();
  for (let descriptor of descriptors) {
    if (seenEventTypes.has(descriptor.type)) {
      continue;
    }
    seenEventTypes.add(descriptor.type);
    let dispatch = createDispatcher(target, descriptor.type);
    let factoryResult = descriptor.factory({ dispatch, target }, descriptor.factoryOptions);
    if (factoryResult) {
      let factoryCleanups = Array.isArray(factoryResult) ? factoryResult : [factoryResult];
      cleanups.push(...factoryCleanups);
    }
  }
}
function attach(target, eventType, descriptors, cleanups) {
  log("attach", { target, eventType, descriptors });
  let preventedEvents = /* @__PURE__ */ new Set();
  for (let descriptor of descriptors) {
    let controller = new AbortController();
    let wrappedHandler = (event) => {
      controller.abort(new DOMException("Handler reentered", "EventReentry"));
      controller = new AbortController();
      log("wrappedHandler", { target, eventType, event });
      if (preventedEvents.has(event)) {
        log("prevented", { target, eventType, event });
        return;
      }
      let call = descriptor.handler(event, controller.signal);
      if (call instanceof Promise) {
        call.catch((e) => {
          if (e instanceof DOMException && e.name === "EventReentry") {
          } else {
            throw e;
          }
        });
      }
      if (event.defaultPrevented) {
        preventedEvents.add(event);
        setTimeout(() => preventedEvents.delete(event), 0);
      }
    };
    target.addEventListener(eventType, wrappedHandler, descriptor.options);
    cleanups.push(() => {
      controller.abort();
      target.removeEventListener(eventType, wrappedHandler, descriptor.options);
    });
  }
}
function attachStandardEvents(target, descriptors, cleanups) {
  let eventsByType = /* @__PURE__ */ new Map();
  for (let descriptor of descriptors) {
    if (!eventsByType.has(descriptor.type)) {
      eventsByType.set(descriptor.type, []);
    }
    eventsByType.get(descriptor.type).push(descriptor);
  }
  for (let [type, descriptors2] of eventsByType) {
    attach(target, type, descriptors2, cleanups);
  }
}
function attachInteractions(target, descriptors, cleanups) {
  let byType = /* @__PURE__ */ new Map();
  for (let descriptor of descriptors) {
    if (!byType.has(descriptor.type)) {
      byType.set(descriptor.type, []);
    }
    byType.get(descriptor.type).push(descriptor);
  }
  for (let [type, descriptors2] of byType) {
    attach(target, type, descriptors2, cleanups);
  }
}
function attachAllEvents(target, descriptors, cleanups) {
  let { custom, standard } = splitDescriptors(descriptors);
  prepareInteractions(target, custom, cleanups);
  attachInteractions(target, custom, cleanups);
  attachStandardEvents(target, standard, cleanups);
}
function splitDescriptors(descriptors) {
  let custom = [];
  let standard = [];
  for (let descriptor of descriptors) {
    if (isInteractionDescriptor(descriptor)) {
      custom.push(descriptor);
    } else {
      standard.push(descriptor);
    }
  }
  return { custom, standard };
}
function isInteractionDescriptor(descriptor) {
  return descriptor.isCustom === true;
}
function descriptorsChanged(descriptors, nextDescriptors) {
  if (descriptors.length !== nextDescriptors.length) {
    return true;
  }
  for (let i = 0; i < descriptors.length; i++) {
    let current = descriptors[i];
    let next = nextDescriptors[i];
    if (current.type !== next.type || current.isCustom !== next.isCustom || !shallowEqual(current.options, next.options) || !shallowEqual(current.factoryOptions, next.factoryOptions)) {
      return true;
    }
  }
  return false;
}
function updateHandlersInPlace(descriptors, nextDescriptors) {
  for (let i = 0; i < nextDescriptors.length; i++) {
    descriptors[i].handler = nextDescriptors[i].handler;
  }
}
function cleanupAll(cleanups) {
  for (let cleanup of cleanups)
    cleanup();
}

// node_modules/@remix-run/events/dist/lib/targets.js
function createTargetProxy() {
  return new Proxy(function targetFunction(type, handler, options) {
    return bind(type, handler, options);
  }, {
    get(target, prop) {
      if (typeof prop === "string") {
        return function(handler, options) {
          return bind(prop, handler, options);
        };
      }
      return target[prop];
    }
  });
}
var dom = createTargetProxy();
var xhr = createTargetProxy();
var win = createTargetProxy();
var doc = createTargetProxy();
var ws = createTargetProxy();

export {
  createInteraction,
  events,
  dom,
  doc
};
//# sourceMappingURL=chunk-W54O7O5R.js.map
